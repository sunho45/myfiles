<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>코드 고찰</title>
  <style>
    pre code {
      background: grey;
      display: block;
      padding: 10px;
      

      border-radius: 8px;
      font-family: Consolas, "Courier New", monospace;
      white-space: pre; /* 줄바꿈, 공백 그대로 유지 */
    }

    ol li{
        font-style:bold;
        font-size:20px;
        background-color: black;
    }
    ul li{
        font-style:bold;
        font-size:20px;
        background-color: black;



    }



  </style>
</head>
<body>
  <h1>이번 코드에 대한 고찰</h1>

  <pre><code>
#include &lt;iostream&gt;
using namespace std;

class dividess {
public:
    int *num1;
    int *num2;

    dividess(int *num1, int *num2) : num1(num1), num2(num2) {}

    void print() {
        cout &lt;&lt; (*num1) / (*num2) &lt;&lt; endl;
    }

    ~dividess() {
        delete [] num1;
        delete [] num2;
    }
};

int main() {
    int *num1;
    int *num2;
    int a, b;

    cin >> a;
    cin>> b;

    num1 = &amp;a;
    num2 = &amp;b;

    dividess d(num1, num2);
    d.print();
}
  </code></pre>

  <p>
    위 코드에서 <code>num1</code>과 <code>num2</code>는 스택 변수 <code>a</code>, <code>b</code>의 주소를 가리킵니다.
    따라서 소멸자에서 <code>delete[]</code>로 해제하면 안 됩니다.
  </p>

  <h2>  <b>stlcontainer functionlist</b></h2>



  <h3>queue</h3>
  <ol>

    <h4>declaration: queue<<type>> qu; </h4>

    <li>
      <p> queue.push(x) :원소 x를 추가</p>
    </li>
      <li>
        queue.pop() :원소 x를 꺼내고 제거(단 return값이 없기에 front르 먼저꺼내야함)
    </li>

      <li>
        queue.front() :큐 컨테이너 내에 있는 함수중에 앞에 있는 값을 반환한다
    </li>

      <li>
        queue.back() :큐 컨테이너 내에 있는 함수중에 뒤에 있는 값을 반환한다
    </li>

      <li>
        queue.size() :queue의 사이즈 반환
    </li>

      <li>
        queue.empty():큐가 비었는지 확인
        
    </li>






  </ol>

<h3>stack</h3>
<h4>  declaration: stack< int> st; </h4>
<ul>
    <li>
        stack.push():stack에 값 추가;
    </li>
<li>
stack.top():stack에있는 최우선 호출 대상을 호출함
</li>
<li>
stack.pop():stack에있는 최우선 호출대상을 제거
</li>
<li>
    stack.size():stack의 사이즈 int값을 반환
</li>
<li>
    stack.empty():스택이 비었는지 안비었는지 알려줌 비었으면 true차있으면 false 반환
</li>





</ul>
<hr>
<h3>priority_queue<int> pq</h3>
    <ol>
        <li>

                pq.push(x):원소 x를 집어넣음




        </li>
        <li>
            pq.pop():최우선 값을 제거 이것도 리턴값이 없음
        </li>
        <li>
            pq.top():최우선에 있는 값을 반환
        </li>

        <li>
    pq.size():stack의 사이즈 int값을 반환
</li>
<li>
    pq.empty():스택이 비었는지 안비었는지 알려줌 비었으면 true차있으면 false 반환
</li> 

<li>

    일반적으로 우선순위 큐는 최대합으로 운영되기에 최소로 바꿀려면
    <br>
    priority_queue<int,vector<int>,greater<int>> pq=로 바꿔준다.
</li>




    </ol>
<hr>

<h3>vector 함수</h3>
declaration:vector<int> vec(n,val);
  n은 크기, val은 어떤값을 채워놓을지에대해서
<ol>

<li>

vec.size():벡터의 현재 크기<br>

vec.capacity():벡터에 할당된 크기

</li>
<li>

  vec.at(i), i+1번째 있는 값의 값 반환<br>
  vec[i]:i+1번째 있는 값 반환 단 vec.at(i)와 달리 i>=vec.size()시 범위 체크 안함
</li>
<li>
vec.front():앞에 있는 값 반환
vec.back():뒤에 있는 값 반환

</li>
<li>
  vec.resize(n):사이즈를 n으로 초기화 부족하면 0이됨
</li>
<li>
  vec.shrink_to_fit():벡터의 capacity를 size로 줄임
</li>
<li>
  vec.data():벡터의 첫번쨰 원소의 주소값을 의미함<br>
  ex) vector <int> vec=3,10,8}일때 <br?



</li>

<li>


  vec.push_back(x):원소 x를 뒤에 삽입함
</li>
<li>


  vec.pop_back(x):뒤에 있는 원소를 제거함
</li>

<li>
vec.erase(pos); 원하는 pos의 원소를 제거함
</li>

<li>
vec.insert(pos,val):원하는 pos에다 val을 삽입함
</li>

<li>
  vec.clear():벡터안에 있는 원소들을 전부 0으로 초기화
</li>
<li>
  vec.swap(v1); vec에 있는 데이터를 전부 v1으로 가게
</li>

<li>
vec.assign(n,val);
벡터를 다시n의 크기로 재지정

</li>





</ol>

<hr>
<h3>deque</h3>
<ul>
declaration: deque<int>dq(n,val)
  참고로 이런식으로 초기화도 가능
<pre>
<code>
#include <iostream>
#include <vector>
#include <deque>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3, 4, 5};

    // v[1] ~ v[3] (2,3,4) 를 복사해서 deque 생성
    deque<int> dq(v.begin() + 1, v.begin() + 4);

    for (int x : dq) cout << x << " ";
    // 출력: 2 3 4
}



</code>


</pre>
<li>
  dq.size():벡터의 현재 크기<br>

dq.capacity():벡터에 할당된 크기
</li>
<br>
<li>
dq.push_front(x): dq의 앞에 특정 원소 x삽입
<br>
dq.push_back(x);dq의 뒤에 특정원소 x삽입




</li>
<li>

  dq.pop_front():dq의 프론트 값 제거
  dq.pop_back():dq의 뒤의 값제거
</li>
<li>


dq.insert(pos,val):dq의 pos위치에 val삽입
<br>
dq.erase(pos);:특정 pos에있는 값 제거
<br>
dq.erase(first,end):dq의 퍼스트부터 엔드에 있는 값 제거


</li>

<li>
  dq.empty():dq가 비었으면 true값 반환 차있으면 false값 반환
<br>
dq.clear():dq에 있는값 제거

</li>

<li>
  dq.swap(v1):v1의 값을 dq로 변환
</li>



</ul>

<hr>
<h2>list</h2>
declaration: 
<ol>list<int> li(n,val)='n의 크기로 val을 채운 리스트'
<li>
li.size():list의 현재 크기
list.cpacity():현재 리스트에 할당된 크기
</li>
<li>
li.push_front(x):리스트의 앞에 특정웒소 x 삽입
li.push_back(x):리스크의 뒤에 특정원소 x삽입
</li>
<li>
li.pop_back():리스트의 뒤에 원소 제거
li.pop_front():리스트의 앞에 원소 x제거
</li>
<li>
li.insert(pos,val)
<br>
li.erase(pos);
<br>
li.erase(firts,end)


</li>
<li>


  li.clear():li에 있는 값 전부 제거
  <br>
  li.empty():li가 비었는지 아닌지 확인
</li>

<h4>
list에만 있는 특별한 함수
</h4>
<li>
  li.remove(val):리스트에 있는 특별한 값 지우기<br>
  li.unique():중복함수 지우기
  li.merge(other_list):다른 리스트와 병합
</li>
<li>
  li.sort():리스트 내 원소 정렬
</li>
<li>
  li.reverse():리스트 내 원소 거꾸로 뒤집음 ex: 2 3 1 -> 1 3 2"</li>





</ol>


<hr>

<h2>set</h2>
set<int>  s(n,val);



  <h3>반복자</h3>
  <hr>
<ol>


<pre>
<code>
set <int> s={30,40,50};
  auto it=s.begin()


</code>


</pre>

<li>

s.begin()은 첫번쨰 값을 가리키는 값. 반복자임에도 포인터의 특성을 지니고 있다.

<br>
ex:cout*itendl; =>30;
<br>
s.end()는 마지막 원소를 가리키는 게 아님. 그마지막 값의 다음 주소를 가리킴
아직 주소 자체 살아있기에 유효하지만 그값에 역참조를 할떄는 세그멘테이션 펄트 발생

s.find(val):목표한 값을 찾으면 그 값을 가리키는 반복자 값 반환 없을 시 반복자 s.end()반환
<br>
ex:
<br>
<pre>
  <code>
set <int> s={30,40,50};
  auto it=s.find(40) /*원소가 안에 있을시 그의 주소값에 맞는 반복자 반환 */
  auto its=s.find(70) /*원소가 그안에 없으므로 s.end()값 반환  */

if(it!=s.end()){
  print(*it) /* 40반환*/
}
if(its!=s.end()){
  print(*its) /* 출력안됨*/
}





  </code>
</pre>


</li>
<li>
  s.count(val):원소 val의 개수를 표시함
<pre>
  <code>
set <int> s={30,40,50};
1=s.count(30)


0=s.count(70)



  </code>
</pre>

</li>

<li>

  s.insert(s.begin(),val):셋의 val의 삽입 위치를 힌트를 주고 알려줌  
</li>

<li>
  s.erase(val):특정val을 제거함
  s.erase(s.begin(),s.end())원하는 위치 첫 시작점부터 끝까지 제거 가능하다
</li>

<li>
  s.clear():s에 있는 데이터 전부 제거
</li>
<li>
  s.empty():s가 비었으면 true 차있으면 false를 내놓는다
</li>
</ol>

<hr>
<h2>map</h2>
<pre>
<code>

#include <iostream>
#include <map>
using namespace std;

int main() {
    map<string,int> mp;

    mp.insert({"apple", 3});
    mp.insert({"banana", 5});
    mp.emplace("cherry", 7);

    cout << "apple: " << mp["apple"] << endl;  // 3

    // 이미 존재하는 키
    auto res = mp.insert({"apple", 10});
    cout << "apple 삽입 성공? " << (res.second ? "Yes" : "No") << endl;

    // 값 수정
    mp["apple"] = 99;

    // 삭제
    mp.erase("banana");

    // 출력
    for (auto &p : mp)
        cout << p.first << " : " << p.second << endl;
}









</code>




</pre>
<h3>
  <p>map의 선언:map<key,vale> mp;</p>
</h3>

<h3>
  map의 삽입
</h3>
<pre>
  <code>
    mp.insert({key,value});

    mp.emplace({key,value})
  </code>
</pre>

<h3>
  map의 삭제
</h3>
<pre>
  <code>
     map.erase(key):key로 삭제한다
  </code>
</pre>

</body>
</html>